srop... 내가 처음으로 커널에 관심을 가지게 된 계기이기도 하다.
때는 3년전, 중1... 그 때 드림핵에는 아마 스테이지 별로 강의가 되어있던 걸로 기억한다.
정확히 어느 부분에서 봤는지는 모르겠다. 기억력이 안 좋은 편이라..
rtl에서 막혔다가 해소되면서 rop까지 쭉 가고... srop를 누군가의 댓글 때문인가, 관심가지게 되었다.
그 땐 그냥 익스플로잇 방법 외워서 풀었다. 그래서 이번엔 좀 제대로 정리해보려고 한다

굳이 시그널 처리하는데 왜 이렇게 여러 번의 유저모드-커널모드 간의 전환이 필요한지에 대해 알아야 한다.

바로 "제한" 때문인데,
커널모드가 맘대로 유저모드에서의 조작이 가능했다면 원래부터 sigcontext, pt_regs, 그리고 이 둘을 묶는 ksignal이 필요하지 않았을 것이다.

설명을 못하니까 차례대로 설명하겠다.
그전에 시그널이 뭐고, 시그널 핸들러가 뭔지는 알아서 보고 와라 ㅉ

1. 유저모드에서 시그널 발생
2. 커널모드에서 뭔가를 함..
3. 유저모드에서 만든 signal handler를 사용함
4. 커널모드에서 뭔갈 함....
5. 다시 바이너리가 잘 돌아가기 시작함..
-> 감지는 do_work_pending()으로 한다고 알고 있다.
-> 이 녀석이 do_signal()을 호출, 근데 커널 버전에 따라 이름이 다르고, 구조도 달라질 수 있으니 걍 알아서 이해해라.
-> 현재 유저 context를 바탕으로 시그널 핸들러, 원래 코드, syscall 재시작 중 하나를 고른다.
.. 역시 귀찮다. 알아서 찾아봐라.
-> get_signal()은 말 그대로 시그널을 가져오는 녀석이다. 시그널 번호, 시그널 발생지, 시그널 발생원인, 시그널 처리 방식, 핸들러 주소, 마스크 등을 가져온다.
-> 처리해야할 시그널이 있는 경우 참을 리턴하는 함수다.

결국엔
sigreturn으로 이동시키고, 여기서 sigcontext라고 취급되는 ebp+12에 위치한 녀석을 pt_regs에 복사할 것임.
수동으로 레지스터 하나하나 수정해도 되긴 하는데...
여기선 execve() 호출해서 쉘 얻는게 전부임.
그래서 esp, eip, ebx, eax만 수정하면 끝

esp는 왜 수정하냐? < sigreturn 끝나고 int 0x80(syscall)있는 곳으로 이동하게 하기 위함
eip? < 실행할 명령어를 int 0x80으로 지정
ebx? < 32비트라서 첫 번째 인자부터 ebx, ecx, ...임. 그래서 얘를 binsh 주소로 바꿈
eax ? < execve 지정. 시스콜 넘버는 0xb(11)
